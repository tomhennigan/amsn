#!/usr/bin/wish
###############################################################
### Alvaro's Messenger			        ###############
###						###############
### http://aim.homelinux.com/msn.htm            ###############
### airadier@able.es                            ###############
###############################################################
### Original ccmsn				###############
### http://msn.CompuCreations.com/		###############
### Dave Mifsud <dave at CompuCreations dot com>###############
###						###############
### Version 0.3p3 20010926			###############
### Modified 20020430 by Alvaro Iradier Muro    ###############
###############################################################
###
###
###
### COMENTARIO ORIGINAL:
###
### Compu's Messenger - ccmsn
### Copyright (C) 2001 Dave Mifsud
###
### This program is free software; you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation; version 2 of the License
###
### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this program; if not, write to the Free Software
### Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
###
### $Id$
###


set version "0.52"
set date "06/05/2002"
set weburl "http://amsn.sourceforge.net"


#Look if we are launched from a link and set
#the correct working dir
if ![catch {file readlink [info script]} res] {
	set program_dir [file dirname $res]
} else {
  set program_dir [file dirname [info script]]
}

#=======================================================================
set images_folder "[file join $program_dir i]"
set sounds_folder "[file join $program_dir s]"
#=======================================================================

#Load program modules
source [file join $program_dir config.tcl]
source [file join $program_dir migmd5.tcl]
source [file join $program_dir ctadverts.tcl]
source [file join $program_dir lang.tcl]
source [file join $program_dir ctdegt.tcl]
source [file join $program_dir hotmail.tcl]
source [file join $program_dir checkver.tcl]
source [file join $program_dir smileys.tcl]


#by AIM
set unread 0
set notify_command ""
set urlcount 0
set urlstarts { "http://" "https://" "ftp://" "www." }
set typing ""
#end AIM

#=======================================================================
#Default look
font create menufont -family Helvetica -size 11 -weight normal
font create sboldf -family Helvetica -size 11 -weight bold
font create splainf -family Helvetica -size 11 -weight normal
font create bboldf -family Helvetica -size 12 -weight bold
font create bplainf -family Helvetica -size 12 -weight normal
font create bigfont -family Helvetica -size 13 -weight bold
font create examplef -family Helvetica -size 10 -weight normal

option add *Menu.font menufont

set trid 0

set user_info ""
set user_stat "FLN"
set list_fl [list]
set list_rl [list]
set list_al [list]
set list_bl [list]
set list_users [list]
set list_notify [list]
set list_cmdhnd [list]

set sb_num 0
set sb_list [list]
set sb_list_cal [list]

set status_show 0

set list_states {{NLN online #0000FF online online bonline}
		{IDL noactivity #0000A0 online away baway}
		{BRB rightback #0000C0 online away baway}
		{PHN onphone #0000C0 online busy bbusy}
		{BSY busy #C00000 online busy bbusy}
		{AWY away #00A000 online away baway}
		{LUN gonelunch #00A000 online away baway}
		{HDN appearoff #404040 offline offline boffline}
		{FLN offline #404040 offline offline boffline}}


 
#=======================================================================
if {$tcl_platform(platform) == "unix"} {
   set HOME "$env(HOME)/.amsn"
} else {
   set HOME "amsn"
}

set log_dir "${HOME}/logs"
#=======================================================================
for {set i 1} {$i <= 256} {incr i} {
   set c [format %c $i]
   set hex [string tolower %[format %.2X $i]]
   if {![string match \[a-zA-Z0-9\] $c]} {
      if { $c == ")" } {
      	set url_map() $hex
	set url_unmap($hex) "\)"
      } elseif { $c == "," } {
      	set url_map(\,) $hex
	set url_unmap($hex) "\,"
      } else {
        set url_map($c) $hex
        set url_unmap($hex) "$c"
      }	

   }
}
#=======================================================================

proc msg_box {msg} {
   global msgbox_request lang

   if {[info exists msgbox_request]} {
      raise .msgbox
      return 0
   }

   set msgbox_request true
   toplevel .msgbox -width 300 -height 100

   bind .msgbox <Destroy> {
      if {"%W" == ".msgbox"} {
         unset msgbox_request
      }
   }


   wm title .msgbox "[trans title]"
   wm transient .msgbox .
   canvas .msgbox.c -width 300 -height 90 -bg #D0D0E0
   pack .msgbox.c -expand true -fill both

   .msgbox.c create text 150 15 -font sboldf -anchor n \
	-text "$msg" -justify center -width 260

   button .msgbox.c.ok -text "[trans ok]" -bg #D0D0E0 \
     -command "destroy .msgbox" -font bboldf

   .msgbox.c create window 150 80 -window .msgbox.c.ok -anchor s

   tkwait visibility .msgbox
   grab set .msgbox

}

proc launch_browser { url } { 
	global config
	exec $config(browser) $url &
}

proc create_dir {path} {
   global tcl_platform

   if {[file isdirectory $path] == 0} {
      file mkdir $path
      if {$tcl_platform(platform) == "unix"} {
         file attributes $path -permissions 00700
      }
   }
}

#=======================================================================
proc cmsn_draw_about {} {
   global program_dir
   toplevel .about
   wm title .about "Acerca de [trans title]"
   wm transient .about .

   text .about.info -background white -width 60 -height 30 -wrap word \
      -yscrollcommand ".about.ys set" -font   examplef
   scrollbar .about.ys -command ".about.info yview" -background #D0D0E0
   pack .about.ys -side right -fill y
   pack .about.info -expand true -fill both
   set id [open "[file join $program_dir README]" r]
   .about.info insert 1.0 [read $id]
   close $id
   .about.info configure -state disabled
   update idletasks
   set x [expr ([winfo vrootwidth .about] - [winfo width .about]) / 2]
   set y [expr ([winfo vrootheight .about] - [winfo height .about]) / 2]
   wm geometry .about +${x}+${y}
}

proc toggle_status {} {
   global status_show

   if {$status_show} {
      wm state .status withdraw
      set status_show 0
   } else {
      wm state .status normal
      set status_show 1
   }
}

proc status_log {txt {colour ""}} {

   set timestamp [clock format [clock seconds] -format %H:%M:%S]
   .status.info insert end "\[$timestamp\] $txt" $colour
   .status.info yview moveto 1.0

}


proc close_cleanup {} {
  global HOME
  save_config
  catch {file delete $HOME/hotlog.htm} res
}

proc cmsn_draw_main {} {
   global images_folder emotion_files version date weburl lang_list \
     password config

   #User status menu
   menu .my_menu -tearoff 0 -type normal -background #D0D0E0 
   .my_menu add command -label [trans online] -command "change_my_status NLN"
   .my_menu add command -label [trans busy] -command "change_my_status BSY"
   .my_menu add command -label [trans rightback] -command "change_my_status BRB"
   .my_menu add command -label [trans away] -command "change_my_status AWY"
   .my_menu add command -label [trans onphone] -command "change_my_status PHN"
   .my_menu add command -label [trans gonelunch] -command "change_my_status LUN"
   .my_menu add command -label [trans appearoff] -command "change_my_status HDN"

   #Preferences dialog/menu
   menu .pref_menu -tearoff 0 -type normal -background #D0D0E0
	PreferencesMenu .pref_menu
   
   #Language selection menu
   menu .lang_menu -tearoff 0 -type normal -background #D0D0E0

   for {set i 0} {$i < [llength $lang_list]} {incr i} {
     set langelem [lindex $lang_list $i]
     set langshort [lindex $langelem 0] 
     set langlong [lindex $langelem 1]
     .lang_menu add command -label "$langlong" -command \
       "set config(language) $langshort; load_lang;msg_box \"\[trans mustrestart\]\""
   }

   menu .user_menu -tearoff 0 -type normal -background #D0D0E0 

   #Main menu
   menu .main_menu -tearoff 0 -type menubar -background #D0D0E0 \
      -borderwidth 0 -activeborderwidth -0 
#   .main_menu add cascade -label "[trans msn]" -menu .main_menu.msn
#   .main_menu add cascade -label "[trans msg]" -menu .main_menu.msg -state disabled
   .main_menu add cascade -label "[trans help]" -menu .main_menu.help

   .main_menu add cascade -label "[trans msn]" -menu .main_menu.file
   .main_menu add cascade -label "[trans actions]" -menu .main_menu.actions
   .main_menu add cascade -label "[trans tools]" -menu .main_menu.tools


   #File menu
   menu .main_menu.file -tearoff 0 -type normal -background #D0D0E0
   if { [string length $config(login)] > 0 } {
     .main_menu.file add command -label "[trans login] $config(login)" \
       -command cmsn_ns_connect -state normal
   } else {
     .main_menu.file add command -label "[trans login]" \
       -command cmsn_ns_connect -state disabled
   }
   .main_menu.file add command -label "[trans login]..." -command \
     cmsn_draw_login
   .main_menu.file add command -label "[trans logout]" -command cmsn_logout 
   .main_menu.file add cascade -label "[trans mystatus]" \
     -menu .my_menu -state disabled
   .main_menu.file add separator
   .main_menu.file add command -label "[trans inbox]" -command \
     "hotmail_login $config(login) $password"
   .main_menu.file add separator
   .main_menu.file add command -label "[trans savecontacts]..." -state disabled
   .main_menu.file add command -label "[trans loadcontacts]..." -state disabled
   .main_menu.file add separator
   .main_menu.file add command -label "[trans sendfile]..." -state disabled
   .main_menu.file add command -label "[trans openreceived]" -state disabled
   .main_menu.file add separator
   .main_menu.file add command -label "[trans close]" -command exit

   #Actions menu
   set dummy_user "recipient@somewhere.com"
   menu .main_menu.actions -tearoff 0 -type normal -background #D0D0E0
   .main_menu.actions add command -label "[trans sendmsg]..." -command \
     send_im_other -state disabled
   .main_menu.actions add command -label "[trans sendmail]" -command \
      "send_mail $dummy_user" 
   .main_menu.actions add command -label "[trans changenick]..." -command \
     cmsn_change_name
   .main_menu.actions add separator
   .main_menu.actions add command -label "[trans checkver]..." -command \
     "check_version"
   

   #Tools menu
   menu .main_menu.tools -tearoff 0 -type normal -background #D0D0E0
   .main_menu.tools add command -label "[trans addacontact]" -command \
     cmsn_draw_addcontact
   .main_menu.tools add cascade -label "[trans admincontacts]" -command \
     "" -state disabled
   .main_menu.tools add cascade -label "[trans admingroups]" -command \
     "" -state disabled
   .main_menu.tools add separator
   .main_menu.tools add cascade -label "[trans ordercontactsby]" \
     -state disabled
   .main_menu.tools add separator
   .main_menu.tools add cascade -label "[trans options]" -menu .options

   #Options menu
   menu .options -tearoff 0 -type normal -background #D0D0E0
   .options add command -label "[trans changenick]..." -state disabled \
      -command cmsn_change_name -state disabled
   .options add command -label "[trans proxyconf]..." -command cmsn_proxy
   .options add cascade -label "[trans preferences]..." -menu .pref_menu
   .options add separator
   .options add cascade -label "[trans language]..." -menu .lang_menu
   .options add checkbutton -label "[trans sound]" -onvalue 1 -offvalue 0 -variable config(sound)
   .options add checkbutton -label "[trans adverts]" -onvalue 1 -offvalue 0 -variable config(adverts) \
     -command "msg_box \"[trans mustrestart]\""
   .options add checkbutton -label "[trans autohotmaillog]" -onvalue 1 -offvalue 0 -variable config(autohotlogin)
   .options add checkbutton -label "[trans chatsmileys]" -onvalue 1 -offvalue 0 \
     -variable config(chatsmileys)
   .options add checkbutton -label "[trans listsmileys]" -onvalue 1 -offvalue 0 \
     -variable config(listsmileys) 


   #Help menu
   menu .main_menu.help -tearoff 0 -type normal -background #D0D0E0 

   .main_menu.help add command -label "[trans helpcontents]..." -command cmsn_draw_about
   .main_menu.help add separator
   .main_menu.help add command -label "[trans about]..." -command cmsn_draw_about
   .main_menu.help add command -label "[trans version]..." -command \
     "msg_box \"[trans version]: $version - [trans date]: $date\n$weburl\""


   #Messenger menu
#   menu .main_menu.msn -tearoff 0 -type normal -background #D0D0E0 
  
#   .main_menu.msn add command -label "[trans login]..." -command cmsn_draw_login
#   .main_menu.msn add command -label "[trans logout]" -state disabled \
      -command cmsn_logout
#   .main_menu.msn add cascade -label "[trans mystatus]" -state disabled -menu .my_menu
#   .main_menu.msn add separator
#    .main_menu.msn add command -label "[trans addacontact]..." -state disabled \
#      -command cmsn_draw_addcontact
#   .main_menu.msn add command -label "[trans changenick]..." -state disabled \
#      -command cmsn_change_name
#   .main_menu.msn add separator
#   .main_menu.msn add command -label "[trans proxyconf]..." -command cmsn_proxy
#   .main_menu.msn add separator
#   .main_menu.msn add cascade -label "[trans preferences]..." -menu .pref_menu
#   .main_menu.msn add separator
#   .main_menu.msn add cascade -label "[trans language]..." -menu .lang_menu
#   .main_menu.msn add checkbutton -label "[trans sound]" -onvalue 1 -offvalue 0 -variable config(sound)
#   .main_menu.msn add checkbutton -label "[trans adverts]" -onvalue 1 -offvalue 0 -variable config(adverts) \
#     -command "msg_box \"[trans mustrestart]\""

#   .main_menu.msn add checkbutton -label "[trans autohotmaillog]" -onvalue 1 -offvalue 0 -variable config(autohotlogin)
#   .main_menu.msn add separator
#   .main_menu.msn add command -label "[trans close]" -command exit

#   menu .main_menu.msg -tearoff 0 -type normal -background #D0D0E0 
#   .main_menu.msg add separator
#   .main_menu.msg add command -label "[trans other]..." -command send_im_other -state disabled

   image create photo mainback -file ${images_folder}/back.gif   

   #toplevel .main
   wm title . "[trans title] - [trans offline]"
   wm geometry . 275x400-1+0
   wm iconname . "[trans title]"
   wm iconbitmap . @${images_folder}/amsn.xbm
   . conf -menu .main_menu

   frame .main 
   pack .main -expand true -fill both

   image create photo online -file ${images_folder}/online.gif
   image create photo offline -file ${images_folder}/offline.gif
   image create photo away -file ${images_folder}/away.gif
   image create photo busy -file ${images_folder}/busy.gif

   image create photo bonline -file ${images_folder}/bonline.gif
   image create photo boffline -file ${images_folder}/boffline.gif
   image create photo baway -file ${images_folder}/baway.gif
   image create photo bbusy -file ${images_folder}/bbusy.gif

   image create photo blocked -file ${images_folder}/blocked.gif
   
   image create photo colorbar -file ${images_folder}/colorbar.gif
   image create photo mailbox -file ${images_folder}/unread.gif   

   image create photo contract -file ${images_folder}/contract.gif
   image create photo expand -file ${images_folder}/expand.gif   

   image create photo globe -file ${images_folder}/globe.gif   

   foreach img_name $emotion_files {
      image create photo $img_name -file ${images_folder}/${img_name}.gif
   }


   text .main.text -background white -width 30 -height 30 -wrap none \
      -yscrollcommand ".main.ys set" -cursor left_ptr -font splainf \
      -selectbackground white -selectborderwidth 0 -exportselection 0
   scrollbar .main.ys -command ".main.text yview" -background #D0D0E0
   text .main.status -background #D0D0E0 -width 30 -height 1 -wrap none

   adv_initialize .main $config(proxy)
   # This one is not a banner but a branding. When adverts are enabled
   # they share this space with the branding image. The branding image
   # is cycled in between adverts.
   adv_show_banner  file ${images_folder}/logolinmsn.gif

   pack .main.status -side bottom -fill x
   pack .main.ys -side right -fill y
   pack .main.text -expand true -fill both

   .main.status configure -state disabled
   bind .main.status <Double-Button-3> toggle_status
   bind .main <Destroy> "close_cleanup"

   cmsn_draw_status
   cmsn_draw_offline
}

proc cmsn_draw_status {} {
   toplevel .status
   wm state .status withdraw
   wm title .status "status log - [trans title]"

   text .status.info -background white -width 60 -height 30 -wrap word \
      -yscrollcommand ".status.ys set" -font splainf
   scrollbar .status.ys -command ".status.info yview" -background #D0D0E0
   entry .status.enter -background white

   pack .status.enter -side bottom -fill x
   pack .status.ys -side right -fill y
   pack .status.info -expand true -fill both

   .status.info tag configure green -foreground darkgreen -background white
   .status.info tag configure red -foreground red -background white
   .status.info tag configure white -foreground white -background black

   bind .status.enter <Return> ns_enter
   wm protocol .status WM_DELETE_WINDOW { toggle_status }
}

proc cmsn_draw_offline {} {

   global sboldf config

   wm title . "[trans title] - [trans offline]"

   .main.status configure -state normal -font splainf
   .main.status delete 0.0 end
   .main.status insert end "[trans offline]"


   .main.status configure -state disabled 

   .main.text configure -state normal 
   .main.text delete 0.0 end

   #Iniciar sesion

   .main.text tag conf check_ver -fore #777777 -underline true \
   -font splainf -justify left
   .main.text tag bind check_ver <Enter> \
	    ".main.text tag conf check_ver -fore #0000A0 -underline false;\
	    .main.text conf -cursor hand2"
   .main.text tag bind check_ver <Leave> \
	    ".main.text tag conf check_ver -fore #000000 -underline true;\
	    .main.text conf -cursor left_ptr"
   .main.text tag bind check_ver <Button-1> \
	    "check_version"

   .main.text tag conf lang_sel -fore #777777 -underline true \
   -font splainf -justify left
   .main.text tag bind lang_sel <Enter> \
	    ".main.text tag conf lang_sel -fore #0000A0 -underline false;\
	    .main.text conf -cursor hand2"
   .main.text tag bind lang_sel <Leave> \
	    ".main.text tag conf lang_sel -fore #000000 -underline true;\
	    .main.text conf -cursor left_ptr"
   .main.text tag bind lang_sel <Button-1> \
	    "tk_popup .lang_menu %X %Y"


   .main.text tag conf start_login -fore #000000 -underline true \
   -font sboldf -justify center
   .main.text tag bind start_login <Enter> \
	    ".main.text tag conf start_login -fore #0000A0 -underline false;\
	    .main.text conf -cursor hand2"
   .main.text tag bind start_login <Leave> \
	    ".main.text tag conf start_login -fore #000000 -underline true;\
	    .main.text conf -cursor left_ptr"
    .main.text tag bind start_login <Button-1> \
        "cmsn_ns_connect"


   .main.text tag conf start_loginas -fore #000000 -underline true \
   -font sboldf -justify center
   .main.text tag bind start_loginas <Enter> \
	    ".main.text tag conf start_loginas -fore #0000A0 -underline false;\
	    .main.text conf -cursor hand2"
   .main.text tag bind start_loginas <Leave> \
	    ".main.text tag conf start_loginas -fore #000000 -underline true;\
	    .main.text conf -cursor left_ptr"
    .main.text tag bind start_loginas <Button-1> \
        "cmsn_draw_login"    

   .main.text image create end -image globe -pady 5 -padx 5
   .main.text insert end "[trans language]\n" lang_sel



   .main.text insert end "\n\n\n\n"
 
   if { $config(login) != "" } {
     .main.text insert end "$config(login)\n" start_login
     .main.text insert end "[trans clicktologin]" start_login
     .main.text tag bind start_login <Button-1> \
	"cmsn_ns_connect"

     .main.text insert end "\n\n\n\n\n"
 
     .main.text insert end "[trans loginas]...\n" start_loginas
     .main.text insert end "\n\n\n\n\n\n\n\n\n"
     
   } else {
     .main.text insert end "[trans clicktologin]..." start_loginas

     .main.text insert end "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"	

   }


   .main.text insert end "   "
   .main.text insert end "[trans checkver]...\n" check_ver
   
   .main.text configure -state disabled


   #Log in
   .main_menu.file entryconfigure 0 -state normal
   .main_menu.file entryconfigure 1 -state normal
   #Log out
   .main_menu.file entryconfigure 2 -state disabled 
   #My status
   .main_menu.file entryconfigure 3 -state disabled
   #Add a contact
   .main_menu.tools entryconfigure 0 -state disabled
   #Change nick
   .main_menu.actions entryconfigure 2 -state disabled
   .options entryconfigure 0 -state disabled
   #Proxy Config
   .options entryconfigure 1 -state normal

#OLD MENUS
#   .main_menu entryconfigure 0 -state disabled
#   .main_menu.msn entryconfigure 0 -state normal
#   .main_menu.msn entryconfigure 1 -state disabled
#   .main_menu.msn entryconfigure 2 -state disabled
#   .main_menu.msn entryconfigure 4 -state disabled
#   .main_menu.msn entryconfigure 5 -state disabled
#   .main_menu.msn entryconfigure 7 -state normal
}

proc cmsn_draw_signin {} {

   .main.status configure -state normal -font splainf
   .main.status delete 0.0 end
   .main.status insert end "[trans loggingin]..."
   .main.status configure -state disabled

   .main.text configure -state normal -font splainf
   .main.text delete 0.0 end
   .main.text tag conf signin -fore #000000 \
   -font sboldf -justify center
   .main.text insert end "\n\n\n\n\n\n\n"
   .main.text insert end "[trans loggingin]..." signin
   .main.text insert end "\n"
   .main.text configure -state disabled

}

proc cmsn_draw_login {} {
   global config password login_request

   if {[info exists login_request]} {
      raise .login
      return 0
   }

   set login_request true
   toplevel .login
   bind .login <Destroy> {if {"%W" == ".login"} { unset login_request } }

   wm geometry .login
   wm title .login "[trans login] - [trans title]"
   wm transient .login .
   canvas .login.c -width 400 -height 150 -bg #D0D0E0
   pack .login.c -expand true -fill both

   entry .login.c.signin -width 20 -bg #FFFFFF -bd 1 -font splainf
   entry .login.c.password -width 20 -bg #FFFFFF -bd 1 \
      -font splainf -show "*"
      
   button .login.c.ok -text [trans ok] -command login_ok -bg #D0D0E0 -font sboldf
   button .login.c.cancel -text [trans cancel] -bg #D0D0E0 \
      -command "grab release .login;destroy .login" -font sboldf

   checkbutton .login.c.remember -bg #D0D0E0 -variable config(save_password) \
      -text "[trans rememberpass]" -font sboldf -activebackground #D0D0E0 \
      -highlightthickness 0 -activeforeground #FFFFFF -selectcolor #FFFFFF

   .login.c create text 133 12 -font sboldf -anchor ne \
	-text "[trans user]: "
   .login.c create text 133 82 -font sboldf -anchor ne \
	-text "[trans pass]: "
   .login.c create text 133 32 -font examplef -anchor ne \
	-text "[trans examples]: "
   .login.c create text 133 32 -font examplef -anchor nw \
	-text "gudidu@hotmail.com\nmyname@msn.com\nexample@passport.com"
   .login.c create window 133 10 -window .login.c.signin -anchor nw
   .login.c create window 133 80 -window .login.c.password -anchor nw
   .login.c create window 133 100 -window .login.c.remember -anchor nw
   .login.c create window 195 120 -window .login.c.ok -anchor ne
   .login.c create window 205 120 -window .login.c.cancel -anchor nw

   .login.c.signin insert 0 $config(login)
   .login.c.password insert 0 $password

   bind .login.c.password <Return> "login_ok"

   tkwait visibility .login
   grab set .login
}

proc cmsn_draw_online {} {
   global emotions user_stat login list_users list_states user_info list_bl\
    unread config showonline password

   set my_name [urldecode [lindex $user_info 4]]
   set my_state_no [lsearch $list_states "$user_stat *"]
   set my_state [lindex $list_states $my_state_no]
   set my_state_desc [trans [lindex $my_state 1]]
   set my_colour [lindex $my_state 2]
   set my_image_type [lindex $my_state 5]

   .main.status configure -state normal
   .main.status delete 0.0 end
   .main.status insert end $my_state_desc
   .main.status configure -state disabled

   .main.text configure -state normal -font splainf
   .main.text delete 0.0 end


   .main.text tag conf mystatus -fore $my_colour -underline false \
     -font bboldf

    .main.text tag bind mystatus <Enter> \
      ".main.text tag conf mystatus -under true;.main.text conf -cursor hand2"
    .main.text tag bind mystatus <Leave> \
      ".main.text tag conf mystatus -under false;.main.text conf -cursor left_ptr"

   .main.text tag bind mystatus <Button-1> "tk_popup .my_menu %X %Y"
   .main.text tag bind mystatus <Button-3> "tk_popup .my_menu %X %Y"


   .main.text tag conf mail -fore black -underline true -font splainf
   .main.text tag bind mail <Button-1> "hotmail_login $config(login) $password"
   .main.text tag bind mail <Enter> \
   	".main.text tag conf mail -under false;.main.text conf -cursor hand2"
   .main.text tag bind mail <Leave> \
   	".main.text tag conf mail -under true;.main.text conf -cursor left_ptr"

   .main.text tag conf online -fore #000000 -font sboldf
   .main.text tag bind online <Button-1> \
     "set config(showonline) [expr !$config(showonline)];cmsn_draw_online"
   .main.text tag bind online <Enter> \
   	".main.text tag conf online -under true;.main.text conf -cursor hand2"
   .main.text tag bind online <Leave> \
   	".main.text tag conf online -under false;.main.text conf -cursor left_ptr"

   .main.text tag conf offline -fore #000000 -font sboldf
   .main.text tag bind offline <Button-1> \
     "set config(showoffline) [expr !$config(showoffline)];cmsn_draw_online"
   .main.text tag bind offline <Enter> \
   	".main.text tag conf offline -under true;.main.text conf -cursor hand2"
   .main.text tag bind offline <Leave> \
   	".main.text tag conf offline -under false;.main.text conf -cursor left_ptr"

   .main.text insert end "\n"
   .main.text image create end -image $my_image_type -pady 0 -padx 0
   .main.text insert end "   $my_name " mystatus
   .main.text insert end "($my_state_desc)\n" mystatus
   .main.text image create end -image colorbar
   .main.text insert end "\n"
   .main.text image create end -image mailbox -pady 0 -padx 5

   .main.text insert end "[trans newmail $unread]\n" mail
#end AIM

   .main.text insert end "\n"
   if { $config(showonline) } {
       .main.text image create end -image contract -pady 0 -padx 5
   } else {
       .main.text image create end -image expand -pady 0 -padx 5
   }
   .main.text insert end "[trans uonline]\n" online

   .main.text insert end "\n"
   if { $config(showoffline) } {
       .main.text image create end -image contract -pady 0 -padx 5
   } else {
       .main.text image create end -image expand -pady 0 -padx 5
   }
   .main.text insert end "[trans uoffline]\n" offline

   set onlinenum 0
   set offlinenum 0

   foreach user $list_users {
      set user_login [lindex $user 0]
      set user_name [lindex $user 1]
      set user_state_no [lindex $user 2]
      set state [lindex $list_states $user_state_no]
      set state_code [lindex $state 0]
      if { ($state_code == "FLN" || $config(showonline) != 0) \
        && ($state_code != "FLN" || $config(showoffline) != 0) } {

      if {($state_code != "NLN") && ($state_code !="FLN")} {
         set state_desc " ([trans [lindex $state 1]])"
      } else {
         set state_desc ""
      }
      set colour [lindex $state 2]
      set section [lindex $state 3]
      set image_type [lindex $state 4]
      if {[lsearch $list_bl "$user_login *"] != -1} {
         set image_type "blocked"
	 if {$state_desc == ""} {set state_desc " ([trans blocked])"}
      }
        .main.text tag conf $user_login -fore $colour


      .main.text mark set new_text_start end
      .main.text insert $section.last "$user_name$state_desc\n" $user_login
#by AIM
#	   foreach emotion $emotions {
#	      set symbol [lindex $emotion 0]
#	      set file [lindex $emotion 1]
#	      set chars [string length $symbol]
#	      while {[set pos [.main.text search -exact -nocase \
#	                              $symbol new_text_start end]] != ""} {
#	         set posyx [split $pos "."]
#	         set endpos "[lindex $posyx 0].[expr [lindex $posyx 1] + $chars]"
#	         .main.text delete $pos $endpos

#	         .main.text image create $pos -image $file -pady 1 -padx 1

#	      }
#	   }
#end AIM	


        .main.text image create $section.last -image $image_type -pady 1 -padx 3
        .main.text insert $section.last "      "
        .main.text tag bind $user_login <Enter> \
            ".main.text tag conf $user_login -under true;.main.text conf -cursor hand2"
        .main.text tag bind $user_login <Leave> \
            ".main.text tag conf $user_login -under false;.main.text conf -cursor left_ptr"
        .main.text tag bind $user_login <Button-3> "show_umenu $user_login %X %Y"
         if { $state_code !="FLN" } {
           .main.text tag bind $user_login <Double-Button-1> \
	     "cmsn_chat_user $user_login"
         }


     }
   }

   if $config(listsmileys) {
     smile_subst .main.text
   }  
   .main.text configure -state disabled
}

proc block_user {user_login} {
   write_ns_sock REM "AL ${user_login}"
   write_ns_sock ADD "BL ${user_login} ${user_login}"
}

proc unblock_user {user_login} {
   write_ns_sock REM "BL ${user_login}"
   write_ns_sock LST "RL"
}

proc delete_user {user_login} {
   write_ns_sock REM "FL ${user_login}"
#   write_ns_sock REM "AL ${user_login}"
}

proc send_mail {user_login} {
  global config

  set mail_param ""
  if {[string first "balsa" $config(mailcommand)] != -1} {
      set mail_param "--compose=$user_login"
  } elseif {[string first "mozilla" $config(mailcommand)] != -1} {
      set mail_param "-compose mailto:$user_login"
  }

  exec $config(mailcommand) $mail_param &
}

proc show_umenu {user_login x y} {
   global list_bl

   set blocked [lsearch $list_bl "${user_login} *"]
   .user_menu delete 0 end
   .user_menu add command -label "$user_login" \
      -command "send_mail $user_login"
   .user_menu add separator
   .user_menu add command -label "[trans chat]" \
      -command "cmsn_chat_user ${user_login}"
   .user_menu add separator
   if {$blocked == -1} {
      .user_menu add command -label "[trans block]" -command  "block_user ${user_login}"
   } else {
      .user_menu add command -label "[trans unblock]" \
         -command  "unblock_user ${user_login}"
   }
   .user_menu add command -label "[trans delete]" -command "delete_user ${user_login}"

   tk_popup .user_menu $x $y
}

proc login_ok {} {
   global config password

   set config(login) [.login.c.signin get]
   set password [.login.c.password get]
   grab release .login
   destroy .login

   if [catch { cmsn_ns_connect } res] {
     msg_box "[trans connecterror]"
     sb set ns stat "d"
     cmsn_draw_offline
   }
}

proc copypaste_menu {text x y delete} {

   $text.copypaste delete 0 end
   $text.copypaste add command -label "Copy" \
      -command "clipboard clear; catch { \"\[$text get \[lindex \[$text tag ranges sel\] 0\] \[lindex \[$text tag ranges sel\] 1\]\]\" } res"

    if !$delete {
     $text.copypaste add command -label "Cut" \
        -command "msg_box cy" -state disabled
     $text.copypaste add command -label "Delete" \
        -command "msg_box delete" -state disabled
    } else {
     $text.copypaste add command -label "Cut" \
        -command "msg_box cy"
     $text.copypaste add command -label "Delete" \
        -command "msg_box delete"
    }
   $text.copypaste add separator
   $text.copypaste add command -label "Paste" \
      -command "msg_box paste"

   tk_popup $text.copypaste $x $y
}


proc cmsn_draw_msgwin {} {
   global images_folder sb_num sb_list

   incr sb_num
   set name "sb$sb_num"
   set win_name "msg_[string tolower ${name}]"

   lappend sb_list "$name"
   sb set $name name $name
   sb set $name sock ""
   sb set $name data [list]
   sb set $name users [list]
   sb set $name typers [list]
   sb set $name title "[trans chat]"
   sb set $name flickering 0


   toplevel .${win_name}
   wm title .${win_name} "[trans chat]"
   wm iconify .${win_name}
   wm state .${win_name} withdraw
   wm group .${win_name} ""
   wm iconbitmap . @${images_folder}/amsn.xbm
   
   menu .${win_name}.menu -tearoff 0 -type menubar -background #D0D0E0 \
      -borderwidth 0 -activeborderwidth -0 
   .${win_name}.menu add cascade -label "[trans msn]" -menu .${win_name}.menu.msn
   .${win_name}.menu add cascade -label "[trans invite]" -menu .${win_name}.menu.invite \
      -state disabled

   menu .${win_name}.menu.msn -tearoff 0 -type normal -background #D0D0E0 
   .${win_name}.menu.msn add command -label "[trans save]" \
      -command " ChooseFilename .${win_name}.text ${name} " 
   .${win_name}.menu.msn add separator
   .${win_name}.menu.msn add command -label "[trans close]" \
      -command "destroy .${win_name}" 

   menu .${win_name}.menu.invite -tearoff 0 -type normal -background #D0D0E0
#by AIM Sirve para algo?
   .${win_name}.menu.invite add separator
   .${win_name}.menu.invite add command -label "Otro..." -state disabled
#end AIM
   bind .${win_name}.menu <Enter> "cmsn_msgwin_umenu $name"

   .${win_name} conf -menu .${win_name}.menu

   frame .${win_name}.top
   text .${win_name}.top.text -background #D0D0E0 -borderwidth 0 -width 30 \
      -height 1 -wrap word -yscrollcommand ".${win_name}.top.ys set"
   scrollbar .${win_name}.top.ys -command ".${win_name}.top.text yview" \
      -background #D0D0E0
   text .${win_name}.text -background white -width 50 -height 15 -wrap word \
      -yscrollcommand ".${win_name}.ys set" -exportselection 1
      #-selectforeground white \
      #-selectbackground darkblue -selectborderwidth 1 
   scrollbar .${win_name}.ys -command ".${win_name}.text yview" \
      -background #D0D0E0
   text .${win_name}.status -background #D0D0E0 -width 30 -height 1 -wrap none\
   -font splainf
   frame .${win_name}.in
   text .${win_name}.in.input -background white -width 25 -height 3 -wrap word\
   -font bboldf
   button .${win_name}.in.send -background #D0D0E0 -text [trans send] -width 5 \
      -command "sb_enter $name .${win_name}.in.input" -font bboldf

   pack .${win_name}.top -side top -fill x
   pack .${win_name}.status -side bottom -fill x
   pack .${win_name}.in -side bottom -fill x
   pack .${win_name}.ys -side right -fill y
   pack .${win_name}.text -expand true -fill both

   pack .${win_name}.top.text -side left -expand true -fill x
   pack .${win_name}.in.send -side right -fill y
   pack .${win_name}.in.input -side left -expand true -fill x

   .${win_name}.top.text configure -state disabled
   .${win_name}.text configure -state disabled
   .${win_name}.status configure -state disabled
   .${win_name}.in.send configure -state disabled
   .${win_name}.in.input configure -state disabled


#   .${win_name}.text tag configure sel -foreground white -background darkblue
   .${win_name}.text tag configure green -foreground darkgreen -background white -font bboldf 
   .${win_name}.text tag configure red -foreground red -background white -font bboldf
   .${win_name}.text tag configure blue -foreground blue -background white -font bboldf
   .${win_name}.text tag configure gray -foreground #808080 -background white
   .${win_name}.text tag configure white -foreground white -background black
   .${win_name}.text tag configure url -foreground darkblue -background white -font bboldf -underline true
#   .${win_name}.text tag bind url <Enter> \
#	    ".${win_name}.text tag conf url -underline false;\
#	    .${win_name}.text conf -cursor hand2"
#   .${win_name}.text tag bind url <Leave> \
#	    ".${win_name}.text tag conf url -underline true;\
#	    .${win_name}.text conf -cursor left_ptr"
#   .${win_name}.text tag bind url <Button-1> \
#	    "puts Yendo"
   

   bind .${win_name}.in.input <Return> "sb_enter $name %W; break"
   bind .${win_name}.in.input <Alt-s> "sb_enter $name %W; break"
   bind .${win_name}.in.input <Tab> "focus .${win_name}.in.send; break"
   bind .${win_name}.in.send <Return> \
      "sb_enter $name .${win_name}.in.input; break"
   bind .${win_name}.in.input <Control-Return> {%W insert end "\n"; break}
   bind .${win_name} <Destroy> "cmsn_destroyed_msgwin $name %W"
   
#   menu .${win_name}.text.copypaste -tearoff 0 -type normal -background #D0D0E0 
#   menu .${win_name}.in.copypaste -tearoff 0 -type normal -background #D0D0E0 

#   bind .${win_name}.text <Button-3> "copypaste_menu .${win_name}.text %X %Y 0"
#   bind .${win_name}.in <Button-3> "copypaste_menu .${win_name}.in %X %Y 1"


   return ${name}

}

proc cmsn_destroyed_msgwin {name winpath} {
   global sb_list ${name}_info config
   set win_name "msg_[string tolower ${name}]"

   if {"${winpath}" != ".${win_name}"} {
      return 0
   }

   set idx [lsearch -exact $sb_list $name]
   if {$idx == -1} {
      status_log "tried to destroy unknown SB $name\n" white
      return 0
   }

   set sb_list [lreplace $sb_list $idx $idx]
   if {[sb get $name stat] != "d"} {
      catch {
      puts [sb get $name sock] "OUT"
      close [sb get $name sock]
      } res
   }
   if {$config(keep_logs) && [sb exists $name log_fcid]} {		;# LOGS!
      close [sb get $name log_fcid]
   }
   unset ${name}_info

}

proc cmsn_show_typers {name} {
   global list_users

   set win_name "msg_[string tolower ${name}]"
   .${win_name}.status configure -state normal
   .${win_name}.status delete 0.0 end

   after cancel ".${win_name}.status configure -state normal;\
     .${win_name}.status delete 0.0 end;\
     .${win_name}.status configure -state disabled"


   set num_typers [sb length $name typers]
   if {$num_typers == 0} {
      #TODO last msg received
      set statusmsg ""
   } else {
      if {$num_typers == 1} {
         set is_are "[trans is]"
      } else {
         set is_are "[trans are]"
      }
      
      upvar #0 [sb name $name typers] typers_list
      set statusmsg ""
      
      foreach login $typers_list {
         set idx [sb search $name users "$login *"]
         set usrinfo [sb index $name users $idx]
         set user_name [lindex $usrinfo 1]
         set statusmsg "${statusmsg}${user_name}, "
         after 10000 "catch {.${win_name}.status configure -state normal;\
           .${win_name}.status delete 0.0 end;\
           .${win_name}.status configure -state disabled} res"
      }
      
#	TODO? maybe a chatting mini-tux?
#      .${win_name}.status image create end -image typingimg -pady 0 -padx 2
      set statusmsg [string replace $statusmsg end-1 end " [trans typing $is_are]."]
   }

   .${win_name}.status insert end $statusmsg
   .${win_name}.status configure -state disabled
}

proc cmsn_msgwin_title {name} {
   upvar #0 [sb name $name users] users_list
   set win_name "msg_[string tolower ${name}]"

   if {[llength $users_list]} {
      set title ""
      set topmsg "[trans to]: "
      foreach usrinfo $users_list {
         set user_login [lindex $usrinfo 0]
         set user_name [lindex $usrinfo 1]
         set title "${title}${user_name}, "
         set topmsg "${topmsg}${user_name} <${user_login}>, "
      }
      set title [string replace $title end-1 end " - [trans chat]"]
      set topmsg [string replace $topmsg end-1 end]
   } else {
      set title "[trans chat]"
      set topmsg "[trans nousersinsession]"
   }
   wm title .${win_name} ${title}
   sb set $name title ${title}

   cmsn_msgwin_top $name $topmsg

}

proc sonido {sound} {
  global config sounds_folder config
  if { $config(sound) == 1 } {
    set archivo [file join $sounds_folder $sound.wav]
    catch {exec $config(soundcommand) $archivo} res
  }
}

proc cmsn_msgwin_flicker {name count} {
   set win_name "msg_[string tolower ${name}]"

  after cancel cmsn_msgwin_flicker $name 0
  after cancel cmsn_msgwin_flicker $name 1

   if { [string first $win_name [focus]] != 1 } {

        set count  [expr ( $count +1 ) % 2]
	if ![catch {
	  if { $count == 1 } {
  	     wm title .${win_name} "[trans newmsg]"
  	  } else {
	     wm title .${win_name} [sb get $name title]
	  }
	} res] {	
 	  after 300 cmsn_msgwin_flicker $name $count
	} 
  } else {
  
	  ##TODO: revisar si se ha cerrado la ventana
	  catch {wm title .${win_name} [sb get $name title]} res
  }
   
}

proc cmsn_msgwin_top {name txt} {
   set win_name "msg_[string tolower ${name}]"

   .${win_name}.top.text configure -state normal -font splainf
   .${win_name}.top.text delete 0.0 end
   .${win_name}.top.text insert end $txt
   .${win_name}.top.text configure -state disabled
}

proc cmsn_win_write {name txt {colour ""}} {
   global emotions urlstarts config urlcount

   set win_name "msg_[string tolower ${name}]"

  .${win_name}.text configure -state normal -font splainf


   set text_start [.${win_name}.text index end]
   set posyx [split $text_start "."]   
   set text_start "[expr [lindex $posyx 0]-1].[lindex $posyx 1]"
   
   #.${win_name}.text mark set new_text_start end

   .${win_name}.text insert end "$txt" $colour

   if {$config(keep_logs) && [sb exists $name log_fcid]} {	;# LOGS!
      puts -nonewline [sb get $name log_fcid] $txt
   }



#New by AIM

   
   set endpos $text_start

   foreach url $urlstarts {

      #puts "  Buscando $url"

      while { $endpos != [.${win_name}.text index end] && [set pos [.${win_name}.text search -forward -exact -nocase \
                              $url $endpos end]] != "" } {
		
	
	set urltext [.${win_name}.text get $pos end]
	
	set final 0
	set caracter [string range $urltext $final $final]
	while { $caracter != " " && $caracter != "\n" } {
		set final [expr $final+1]
		set caracter [string range $urltext $final $final]
	}
	
	set urltext [string range $urltext 0 [expr $final-1]]

        set posyx [split $pos "."]
        set endpos "[lindex $posyx 0].[expr [lindex $posyx 1] + $final]"


	#puts "    Encontrado url $urltext en $pos-$endpos"

	set urlcount "[expr $urlcount+1]"
	set urlname "url_$urlcount"

	.${win_name}.text tag configure $urlname \
	  -foreground darkblue -background white -font bboldf -underline true
	.${win_name}.text tag bind $urlname <Enter> \
	  ".${win_name}.text tag conf $urlname -underline false;\
	  .${win_name}.text conf -cursor hand2"
	.${win_name}.text tag bind $urlname <Leave> \
	  ".${win_name}.text tag conf $urlname -underline true;\
	  .${win_name}.text conf -cursor left_ptr"
	.${win_name}.text tag bind $urlname <Button-1> \
	  "launch_browser \"$urltext\""

  	.${win_name}.text delete $pos $endpos
	.${win_name}.text insert $pos "$urltext" $urlname	  
	  
     }


   }
#end by AIM
   
   foreach emotion $emotions {
      set symbol [lindex $emotion 0]
      set file [lindex $emotion 1]
      set chars [string length $symbol]
      while {[set pos [.${win_name}.text search -exact -nocase \
                              $symbol $text_start end]] != ""} {
         set posyx [split $pos "."]
         set endpos "[lindex $posyx 0].[expr [lindex $posyx 1] + $chars]"
         .${win_name}.text delete $pos $endpos

         .${win_name}.text image create $pos -image $file -pady 1 -padx 1

      }
   }

   .${win_name}.text yview moveto 1.0
   .${win_name}.text configure -state disabled

}

proc cmsn_draw_addcontact {} {
   global addcontact_request lang

   if {[info exists addcontact_request]} {
      raise .addcontact
      return 0
   }

   set addcontact_request true
   toplevel .addcontact -width 400 -height 150 
   bind .addcontact <Destroy> {
      if {"%W" == ".addcontact"} {
         unset addcontact_request
      }
   }

   wm geometry .addcontact -0+100
   wm title .addcontact "[trans addacontact] - [trans title]"
   wm transient .addcontact .
   canvas .addcontact.c -width 320 -height 150 -bg #D0D0E0
   pack .addcontact.c -expand true -fill both

   entry .addcontact.c.email -width 30 -bg #FFFFFF -bd 1 \
      -font splainf
   button .addcontact.c.next -text "[trans next]->" -bg #D0D0E0 \
     -command addcontact_next -font sboldf
   button .addcontact.c.cancel -text [trans cancel] -bg #D0D0E0 \
      -command "grab release .addcontact;destroy .addcontact" -font sboldf

   .addcontact.c create text 5 10 -font sboldf -anchor nw \
	-text "[trans entercontactemail]:"
   .addcontact.c create text 70 60 -font examplef -anchor ne \
	-text "[trans examples]: "
   .addcontact.c create text 70 60 -font examplef -anchor nw \
	-text "gudidu@hotmail.com\nmyname@msn.com\nexample@passport.com"
   .addcontact.c create window 5 35 -window .addcontact.c.email -anchor nw
   .addcontact.c create window 195 120 -window .addcontact.c.next -anchor ne
   .addcontact.c create window 205 120 -window .addcontact.c.cancel -anchor nw

   bind .addcontact.c.email <Return> "addcontact_next"

   tkwait visibility .addcontact
   grab set .addcontact
}

proc addcontact_next {} {
   set tmp_email [.addcontact.c.email get]
   write_ns_sock "ADD" "FL $tmp_email $tmp_email"
   grab release .addcontact
   msg_box "[trans contactadded]"
   destroy .addcontact
}

proc cmsn_proxy {} {
   global configuring_proxy config

   if {[info exists configuring_proxy]} {
      raise .proxy_conf
      return 0
   }

   set configuring_proxy true
   toplevel .proxy_conf -width 400 -height 150 
   bind .proxy_conf <Destroy> {
      if {"%W" == ".proxy_conf"} {
         unset configuring_proxy
      }
   }

   wm geometry .proxy_conf -0+100
   wm title .proxy_conf "[trans proxyconf] - [trans title]"
   wm transient .proxy_conf .
   canvas .proxy_conf.c -width 400 -height 150 -bg #D0D0E0
   pack .proxy_conf.c -expand true -fill both

   entry .proxy_conf.c.server -width 20 -bg #FFFFFF -bd 1 \
      -font splainf
   entry .proxy_conf.c.port -width 5 -bg #FFFFFF -bd 1 \
      -font splainf
   button .proxy_conf.c.ok -text [trans ok] -command proxy_conf_ok
   button .proxy_conf.c.cancel -text [trans cancel] \
      -command "grab release .proxy_conf;destroy .proxy_conf"

   .proxy_conf.c create text 200 15 -font bigfont -anchor center \
	-text "[trans proxyconfhttp]"
   .proxy_conf.c create text 133 35 -font sboldf -anchor ne \
	-text "[trans server]: "
   .proxy_conf.c create text 133 60 -font sboldf -anchor ne \
	-text "[trans port]: "
   .proxy_conf.c create text 133 82 -font splainf -anchor nw \
	-text "[trans blankdirect]"
   .proxy_conf.c create window 133 35 -window .proxy_conf.c.server -anchor nw
   .proxy_conf.c create window 133 60 -window .proxy_conf.c.port -anchor nw
   .proxy_conf.c create window 195 120 -window .proxy_conf.c.ok -anchor ne
   .proxy_conf.c create window 205 120 -window .proxy_conf.c.cancel -anchor nw

   set proxy_data [split $config(proxy) ":"]
   .proxy_conf.c.server insert 0 [lindex $proxy_data 0]
   .proxy_conf.c.port insert 0 [lindex $proxy_data 1]

   tkwait visibility .proxy_conf
   grab set .proxy_conf
}

proc proxy_conf_ok {} {
   global config

   set config(proxy) [join [list [.proxy_conf.c.server get] [.proxy_conf.c.port get]] ":"]
   grab release .proxy_conf
   destroy .proxy_conf
}

proc newcontact {new_login new_name} {
   global newc_allow_block newc_add_to_list newc_exit list_fl

   set newc_allow_block "allow"
   set newc_exit ""

   if {[lsearch $list_fl "$new_login *"] != -1} {
      set add_stat "disabled"
      set newc_add_to_list 0
   } else {
      set add_stat "normal"
      set newc_add_to_list 1
   }
   toplevel .newc
 
   wm geometry .newc -0+100
   wm title .newc "$new_name - [trans title]"
   wm transient .newc .
   canvas .newc.c -width 500 -height 150 -bg #D0D0E0
   pack .newc.c -expand true -fill both
 
   button .newc.c.ok -text [trans ok] -bg #D0D0E0 \
      -command "set newc_exit OK;grab release .newc;destroy .newc"
   button .newc.c.cancel -text [trans cancel] -bg #D0D0E0 \
      -command "grab release .newc;destroy .newc"

  radiobutton .newc.c.allow -bg #D0D0E0 -variable newc_allow_block \
     -text [trans allowseen] \
     -activebackground #D0D0E0 -highlightthickness 0 \
     -activeforeground #FFFFFF -selectcolor #FFFFFF -value allow
  radiobutton .newc.c.block -bg #D0D0E0 -variable newc_allow_block \
     -text [trans avoidseen] \
     -activebackground #D0D0E0 -highlightthickness 0 \
     -activeforeground #FFFFFF -selectcolor #FFFFFF -value block
   checkbutton .newc.c.add -bg #D0D0E0 -var newc_add_to_list -state $add_stat \
      -text [trans addtoo] -activebackground #D0D0E0 \
      -highlightthickness 0 -activeforeground #FFFFFF -selectcolor #FFFFFF

 
   .newc.c create text 30 5 -font splainf -anchor nw -justify left \
        -text "$new_name ($new_login) [trans addedyou]." \
        -width 460
   .newc.c create text 30 40 -font splainf -anchor nw \
        -text "[trans youwant]:"
   .newc.c create window 40 58 -window .newc.c.allow -anchor nw
   .newc.c create window 40 76 -window .newc.c.block -anchor nw
   .newc.c create window 30 94 -window .newc.c.add -anchor nw
   .newc.c create window 245 120 -window .newc.c.ok -anchor ne
   .newc.c create window 255 120 -window .newc.c.cancel -anchor nw

   tkwait visibility .newc
   grab set .newc
}

proc cmsn_draw_notify {} {
   global notify_id images_folder

   toplevel .notify -width 150 -height 100
   wm title .notify "[trans msn] [trans notify]"
   wm overrideredirect .notify 1
   wm geometry .notify -10-60
   wm transient .notify .
   wm state .notify withdraw

   canvas .notify.c -bg #EEEEFF -width 150 -height 100 \
      -relief ridge -borderwidth 3
   pack .notify.c

   image create photo notback -file ${images_folder}/notify.gif
   .notify.c create image 75 50 -image notback
   
   set notify_id [.notify.c create text 75 50 -font splainf \
      -justify center -width 145]

   .notify.c bind $notify_id <Enter> \
     ".notify.c itemconfigure $notify_id -font sboldf;\
     .notify.c conf -cursor hand2"
   .notify.c bind $notify_id <Leave> \
     ".notify.c itemconfigure $notify_id -font splainf; \
     .notify.c conf -cursor left_ptr"
   .notify.c bind $notify_id <Button-1> ""   
}

proc cmsn_update_notify {} {
   global list_notify notify_id emotions

   set notify_text ""
   set cursec [clock seconds]
   set items [expr [llength $list_notify] -1]
   for {set idx $items} {$idx >= 0} {incr idx -1} {
      set notify_item [lindex $list_notify $idx]
      set msg [lindex $notify_item 0]
      set msgsec [lindex $notify_item 1]
      if {$msgsec < $cursec} {
         set list_notify [lreplace $list_notify $idx $idx]
      } else {
         set notify_text \n\n$msg${notify_text}
      }
   }

   set notify_text [string range ${notify_text} 2 end]
   .notify.c dchars $notify_id 0 end

#by AIM

#	   foreach emotion $emotions {
#	      set symbol [lindex $emotion 0]
#	      set file [lindex $emotion 1]
#	      set chars [string length $symbol]
#	      while {[set pos [.notify.c search -exact -nocase \
	                              $symbol start end]] != ""} {
#	         set posyx [split $pos "."]
#	         set endpos "[lindex $posyx 0].[expr [lindex $posyx 1] + $chars]"
#	         .notify.c delete $pos $endpos

#	         .notify.c image create $pos -image $file -pady 1 -padx 1

#	      }
#	   }
#end AIM	


   .notify.c insert $notify_id 0 $notify_text


   if {[string length $notify_text] > 0} {
      wm state .notify normal
   } else {
      wm state .notify withdraw
   }

   wm geometry .notify -10-60
   raise .notify
   after 1000 cmsn_update_notify
}

proc cmsn_notify_add {msg {command ""}} {
   global list_notify notify_id

   if {[string length $msg] >100} {
	    lappend list_notify [list [string range $msg 0 100]... [expr [clock seconds] + 7]]
   } else {
	   lappend list_notify [list $msg [expr [clock seconds] + 7]]   
   }

#new by AIM
   .notify.c bind $notify_id <Button-1> $command
#end AIM
}

proc cmsn_change_name {} {
   global change_name

   if {[info exists change_name]} {
      raise .change_name
      return 0
   }

   set change_name true
   toplevel .change_name -width 400 -height 150 
   bind .change_name <Destroy> {
      if {"%W" == ".change_name"} {
         unset change_name
      }
   }
   wm geometry .change_name -0+100
   wm title .change_name "[trans changenick] - [trans title]"
   wm transient .change_name .
   canvas .change_name.c -width 300 -height 100 -bg #D0D0E0
   pack .change_name.c -expand true -fill both

   entry .change_name.c.name -width 40 -bg #FFFFFF -bd 1 \
      -font splainf
   button .change_name.c.ok -text [trans ok] -bg #D0D0E0 -command change_name_ok
   button .change_name.c.cancel -text [trans cancel] -bg #D0D0E0 \
      -command "destroy .change_name"

   .change_name.c create text 5 10 -font sboldf -anchor nw \
	-text "[trans enternick]:"
   .change_name.c create window 5 35 -window .change_name.c.name -anchor nw
   .change_name.c create window 195 65 -window .change_name.c.ok -anchor ne
   .change_name.c create window 205 65 -window .change_name.c.cancel -anchor nw

   bind .change_name.c.name <Return> "change_name_ok"

   tkwait visibility .change_name
   grab set .change_name
}

proc change_name_ok {} {
   global config

   set new_name [.change_name.c.name get]
   if {$new_name != ""} {
      write_ns_sock "REA" "$config(login) [urlencode $new_name]"
   }
   destroy .change_name
}
#=======================================================================

proc cmsn_msgwin_umenu {name} {
   global list_users
   set win_name "msg_[string tolower ${name}]"

   .${win_name}.menu.invite delete 0 end
   .${win_name}.menu.invite add separator
   .${win_name}.menu.invite add command -label "[trans other]..." -state disabled

   foreach user_info $list_users {
      set user_login [lindex $user_info 0]
      set user_state_no [lindex $user_info 2]
      if {($user_state_no < 7) && 
          ([sb search $name users "$user_login *"] == -1)} {
         set user_name [lindex $user_info 1]
	 .${win_name}.menu.invite insert 0 command \
            -command "cmsn_invite_user $name $user_login;puts $user_login" \
	    -label "$user_name <$user_login>"
      }
   }
}

proc cmsn_logout {} {
   global config
   puts -nonewline [sb get ns sock] "OUT\r\n"
   status_log "Loging out\n"
   set list_al [list]
   set list_bl [list]
   set list_fl [list]
   set list_rl [list]      
   status_log "clearing all lists\n"
   if {$config(adverts)} {
      adv_pause
   }
}

proc change_my_status {new_status} {
   write_ns_sock "CHG" $new_status
   status_log "Changing state to $new_status\n" red
}

proc cmsn_sb_sessionclosed {sbn} {
   set win_name "msg_[string tolower ${sbn}]"

   status_log "$sbn: SESSION CLOSED\n" red
   sb set $sbn stat "d"
   .${win_name}.menu entryconfigure 1 -state disabled
   set items [expr [sb length $sbn users] -1]
   sb set $sbn last_user [sb index $sbn users 0]
   for {set idx $items} {$idx >= 0} {incr idx -1} {
      set user_info [sb index $sbn users $idx]
      sb ldel $sbn users $idx
      .${win_name}.in.send configure -state disabled
      cmsn_win_write $sbn "[trans leaves [lindex $user_info 0]]\n" green
      cmsn_msgwin_title $sbn
      bind .${win_name}.in.input <Key> "cmsn_reconnect ${sbn}"
      bind .${win_name}.in.input <Return> "cmsn_reconnect ${sbn}; break"
   }
}

proc read_sb_sock {sbn} {

   set sb_sock [sb get $sbn sock]
   if {[eof $sb_sock]} {
      close $sb_sock
      cmsn_sb_sessionclosed $sbn
   } else {
      gets $sb_sock tmp_data
      sb append $sbn data $tmp_data
      set log [string map {\r ""} $tmp_data]
      #status_log "$sbn: RECV: $log\n" green
      degt_protocol "<-SB $tmp_data"
      if {[string range $tmp_data 0 2] == "MSG"} {
         set recv [split $tmp_data]
	 fconfigure $sb_sock -blocking 1
	 set msg_data [read $sb_sock [lindex $recv 3]]
	 fconfigure $sb_sock -blocking 0
	 sb append $sbn data $msg_data
      }
   }

}
proc write_sb_sock {sbn cmd param {handler ""}} {
   global trid
   incr trid

   puts [sb get $sbn sock] "$cmd $trid $param\r"
   status_log "$sbn: SEND: $cmd $trid $param\n" red
   degt_protocol "->SB $cmd $trid $param"

   if {$handler != ""} {
      global list_cmdhnd
      lappend list_cmdhnd [list $trid $handler]
   }
}

proc sb {do sbn var {value ""}} {
   global ${sbn}_info
   set sb_tmp "${sbn}_info(${var})"
   upvar #0 $sb_tmp sb_data

   switch $do {
      name {
	 return $sb_tmp
      }
      set {
         set sb_data $value
	 return 0
      }
      get {
	 return $sb_data
      }
      append {
         lappend sb_data $value
      }
      index {
         return [lindex $sb_data $value]
      }
      ldel {
         set sb_data [lreplace $sb_data $value $value]
      }
      length {
         return [llength $sb_data]
      }
      search {
         return [lsearch $sb_data $value]
      }
      exists {
         return [info exists $sb_tmp]
      }
      unset {
         unset $sb_tmp
      }
   }

}

proc read_ns_sock {} {
   global ns_data ns_stat unread config password

   set ns_sock [sb get ns sock]
   if {[eof $ns_sock]} {
      close $ns_sock
      sb set ns stat "d"
      status_log "Closing NS socket!\n" red
      cmsn_draw_offline
   } else {
      gets $ns_sock tmp_data
#      sb append ns data $tmp_data

      set log [string map {\r ""} $tmp_data]

      status_log "RECV: <-$log->\n" green
      degt_protocol "<-NS $tmp_data"

      if {[string range $tmp_data 0 2] == "MSG"} {

	#Nuevo by AIM
         if {[string range $tmp_data 4 18] == "Hotmail Hotmail"} {
	 	#puts "Algo de hotmail:  $tmp_data"
		set recv [split $tmp_data]
		set toread [lindex $recv 3]
		if { [lindex $recv 3] == "25631" } {

			#puts "Mensaje leido"
			set unread [expr $unread -1]
			cmsn_draw_online
		
			set count 0
			fconfigure $ns_sock -blocking 1
			while { $count<8165 } {
				set msg_data [read $ns_sock 1]			
				set count [expr $count+1]
				#puts -nonewline "$msg_data"
			}
			fconfigure $ns_sock -blocking 0
		  
		} else	{

			set msg_data [read $ns_sock [lindex $recv 3]]
		
			array set headers {}
			set body ""
			cmsn_msg_parse $msg_data headers body

			set content [lindex [array get headers content-type] 1]
	
			if {[string range $content 0 36] == "application/x-msmsgsemailnotification"} {
				if {[string range $body 0 4] == "From:"} {				
				  	set from [aim_get_str $body From]
					set fromaddr [aim_get_str $body From-Addr]
					status_log "Hotmail: New mail from $from - $fromaddr\n"
					set unread [expr $unread + 1]
					cmsn_notify_add [trans newmailfrom]\n$from\n($fromaddr) \
					 "hotmail_login $config(login) $password"
					sonido newemail
					cmsn_draw_online

				} else {
					set noleidos [aim_get_str $body Inbox-Unread]
					status_log "Hotmail: $noleidos unread emails\n"
					if { [string length $noleidos] > 0 } {
						set unread $noleidos
						cmsn_draw_online
					}
				}
			}
		}
		#End by AIM

	 } else {

		 sb append ns data $tmp_data		 

	         set recv [split $tmp_data]
		 fconfigure $ns_sock -blocking 1
		 set msg_data [read $ns_sock [lindex $recv 3]]
		 status_log "MSGDATA: $msg_data " green
		 fconfigure $ns_sock -blocking 0
	         sb append ns data $msg_data
	 } 
      } else {

         sb append ns data $tmp_data     

      }
   }

}

proc write_ns_sock {cmd param {handler ""}} {
   global trid
   incr trid

   puts -nonewline [sb get ns sock] "$cmd $trid $param\r\n"
   status_log "SEND: $cmd $trid $param\n" red
   degt_protocol "->NS $cmd $trid $param"

   if {$handler != ""} {
      global list_cmdhnd
      lappend list_cmdhnd [list $trid $handler]
   }

}

proc proc_sb {} {
   global sb_list

   foreach sbn $sb_list {
      while {[sb length $sbn data]} {
         set item [split [sb index $sbn data 0]]

         set result [cmsn_sb_handler $sbn $item]
         if {$result == 0} {
	    sb ldel $sbn data 0
         } else {
            status_log "problem processing SB data!\n" red
	    return 0
         } ;# if

      } ;# while
   } ;# foreach

   after 250 proc_sb
}

proc proc_ns {} {



   while {[sb length ns data]} {

      set item [split [sb index ns data 0]]

      set result [cmsn_ns_handler $item]
      if {$result == 0} {
	 sb ldel ns data 0
      } else {
         status_log "problem processing NS data!\n" red
	 return 0
      }

   }

   after 100 proc_ns
}


proc cmsn_msg_parse {msg hname bname} {
   upvar $hname headers
   upvar $bname body

   set head_len [string first "\r\n\r\n" $msg]
   set head [string range $msg 0 [expr $head_len - 1]]
   set body [string range $msg [expr $head_len + 4] [string length $msg]]

   set body [encoding convertfrom utf-8 $body]
   set body [string map {"\r" ""} $body]

   set head [string map {"\r" ""} $head]
   set head_lines [split $head "\n"]
   foreach line $head_lines {
      set colpos [string first ":" $line]
      set attribute [string tolower [string range $line 0 [expr $colpos-1]]]
      set value [string range $line [expr $colpos+2] [string length $line]]
      array set headers [list $attribute $value]
   }

}

proc cmsn_sb_msg {sb_name recv} {

   set msg [sb index $sb_name data 1]

#   status_log "LOG: $msg\n" white

 
   sb ldel $sb_name data 1
   array set headers {}
   set body ""
   cmsn_msg_parse $msg headers body

   set content [lindex [array get headers content-type] 1]
   set timestamp [clock format [clock seconds] -format %H:%M]

   if {[string range $content 0 9] == "text/plain"} {
      cmsn_win_write $sb_name \
        "\[$timestamp\] [trans says [urldecode [lindex $recv 2]]]:\n" gray
      cmsn_win_write $sb_name "$body\n" red
      set idx [sb search $sb_name typers [lindex $recv 1]]
      sb ldel $sb_name typers $idx
      cmsn_show_typers $sb_name
      cmsn_msgwin_flicker $sb_name 20
      
      set win_name "msg_[string tolower ${sb_name}]"

      if { [string compare [wm state .${win_name}] "withdrawn"] == 0 } {
        wm state .${win_name} iconic
	cmsn_notify_add [trans says [urldecode [lindex $recv 2]]]:\n$body \
	  "wm state .${win_name} normal"
      }

      if { [string first $win_name [focus]] != 1 } {
        sonido type
      }
      
   } elseif {[string range $content 0 19] == "text/x-msmsgscontrol"} {

#      status_log "$msg\n" white     
      set typer [array get headers typinguser]
      if {[llength $typer]} {
         set typer [lindex $typer 1]
	 set idx [sb search $sb_name typers "$typer"]
	 if {$idx == -1} {
            sb append $sb_name typers $typer
	 } else {
            sb ldel $sb_name typers $idx
         }
         cmsn_show_typers $sb_name
      }

   } else {
      status_log "=== UNKNOWN MSG ===\n$msg\n" white
   }

}

proc cmsn_update_users {sb_name recv} {
   global config


   switch [lindex $recv 0] {
      BYE { if {[sb get $sb_name stat] != "d"} {
         cmsn_win_write $sb_name "[trans leaves [lindex $recv 1]]\n" green
	 set leaves [sb search $sb_name users "[lindex $recv 1] *"]
	 sb ldel $sb_name users $leaves
	 sb set $sb_name last_user [lindex $recv 1]
      } }
      IRO {
         sb set $sb_name stat "o"
	 set usr_login [lindex $recv 4]
	 set usr_name [urldecode [lindex $recv 5]]
	 sb append $sb_name users [list $usr_login $usr_name]
         cmsn_win_write $sb_name "[trans joins $usr_name ($usr_login)]\n" green
      }
      JOI {
         sb set $sb_name stat "o"
	 set usr_login [lindex $recv 1]
	 set usr_name [urldecode [lindex $recv 2]]
	 sb append $sb_name users [list $usr_login $usr_name]
         cmsn_win_write $sb_name "[trans joins $usr_name ($usr_login)]\n" green
      }
   }

   if {[sb exists $sb_name log_fcid]} {
      close [sb get $sb_name log_fcid]
      sb unset $sb_name log_fcid
   }
   if {$config(keep_logs) && [sb length $sb_name users]} {	;# LOGS!
      global log_dir
      upvar #0 [sb name $sb_name users] tmp_users_list
      set users_list [lsort $tmp_users_list]
      set file_name ""
      foreach usrinfo $users_list {
         set user_email [split [lindex $usrinfo 0] "@"]
	 set user_login [lindex $user_email 0]
         set file_name "${file_name}-${user_login}"
      }
      set file_name [string range ${file_name} 1 end]
      sb set $sb_name log_fcid [open "${log_dir}/${file_name}" a+]
   }

   cmsn_msgwin_title $sb_name
   set win_name "msg_[string tolower ${sb_name}]"
   if {[sb length $sb_name users] > 0} {
      .${win_name}.in.input configure -state normal
      .${win_name}.in.send configure -state normal
      .${win_name}.menu entryconfigure 1 -state normal
      bind .${win_name}.in.input <Key> "sb_change $sb_name"
      bind .${win_name}.in.input <Return> "sb_enter $sb_name %W; break"
   } else {
      if {[sb get $sb_name stat] != "d"} { sb set $sb_name stat "n" }
      .${win_name}.in.send configure -state disabled
      bind .${win_name}.in.input <Key> "cmsn_reconnect ${sb_name}"
      bind .${win_name}.in.input <Return> "cmsn_reconnect ${sb_name}; break"
   }
}

proc cmsn_sb_handler {sb_name item} {
   global list_cmdhnd

   set item [encoding convertfrom utf-8 $item]

   set ret_trid [lindex $item 1]
   set idx [lsearch $list_cmdhnd "$ret_trid *"]
   if {$idx != -1} {		;# Command has a handler associated!
      eval "[lindex [lindex $list_cmdhnd $idx] 1] \"$item\""
      status_log "evaluating handler for $ret_trid\n"
      return 0
   } else {
   switch [lindex $item 0] {
      MSG {
	 cmsn_sb_msg $sb_name $item
	 return 0
      }
      BYE -
      JOI -
      IRO {
	 cmsn_update_users $sb_name $item
	 return 0
      }
      CAL {
	 return 0
      }
      ANS {
         status_log "$sb_name: [join $item]\n" green
	 return 0
      }
      default {
         status_log "$sb_name: UNKNOWN SB ENTRY! --> [join $item]\n" red
	 return 0
      }
   }
   }
}

proc cmsn_invite_user {name user} {
   status_log "$name: Inviting $user\n" green
   write_sb_sock $name "CAL" $user
}

proc cmsn_chat_user {user} {
   set name [cmsn_draw_msgwin]

   sb set $name stat "r"
   sb set $name invite $user

   status_log "$name: CHAT1 Talking with $user\n" green
   write_ns_sock "XFR" "SB" "cmsn_open_sb $name"
   
   cmsn_msgwin_top $name "[trans chatreq]..."
#   if [catch { cmsn_msgwin_top $name "[trans chatreq]..."} res]  {
#     msg_box "Ventana de chat ya cerrada"
#      puts [sb get $name sock] "OUT"
#      close [sb get $name sock]
#   } 

   set win_name "msg_[string tolower ${name}]"
   wm state .${win_name} normal

}

proc cmsn_rng {recv} {
   global config

   set sbn [cmsn_draw_msgwin]
   sb set $sbn serv [split [lindex $recv 2] ":"]
   sb set $sbn connected "cmsn_conn_ans $sbn"
   sb set $sbn readable "read_sb_sock $sbn"
   sb set $sbn auth_cmd "ANS"
   sb set $sbn auth_param "$config(login) [lindex $recv 4] [lindex $recv 1]"

   status_log "$sbn: ANS1 answering [lindex $recv 5]\n" green
   cmsn_msgwin_top $sbn "[trans chatack] [lindex $recv 5]..."
   cmsn_socket $sbn
   return 0
}

proc cmsn_open_sb {sbn recv} {
   global config

   if {[lindex $recv 4] != "CKI"} {
      status_log "$sbn: Unknown SP requested!\n" red
      return 1
   }
   sb set $sbn serv [split [lindex $recv 3] ":"]
   sb set $sbn connected "cmsn_conn_sb $sbn"
   sb set $sbn readable "read_sb_sock $sbn"
   sb set $sbn auth_cmd "USR"
   sb set $sbn auth_param "$config(login) [lindex $recv 5]"

   status_log "$sbn: CHAT2: connecting to Switch Board [lindex $recv 3]\n"   


   if [catch { cmsn_msgwin_top $sbn "[trans sbcon]..."} res]  {
     status_log "Ignoring: Chat window $sbn has been closed\n"
   } else {
     cmsn_socket $sbn
   }
}

proc cmsn_conn_sb {name} {
   fileevent [sb get $name sock] writable {}
   sb set $name stat "a"
   set cmd [sb get $name auth_cmd]; set param [sb get $name auth_param]
   write_sb_sock $name $cmd $param "cmsn_connected_sb $name"
   cmsn_msgwin_top $name "[trans ident]..."
}

proc cmsn_conn_ans {name} {
   fileevent [sb get $name sock] writable {}
   sb set $name stat "a"
   set cmd [sb get $name auth_cmd]; set param [sb get $name auth_param]
   write_sb_sock $name $cmd $param
   cmsn_msgwin_top $name "[trans ident]..."
}

proc cmsn_connected_sb {name recv} {
   sb set $name stat "i"
   if {[sb exists $name invite]} {
      cmsn_invite_user $name [sb get $name invite]
      cmsn_msgwin_top $name \
        "[trans willjoin [sb get $name invite]]..."
   }
}

proc cmsn_reconnect {name} {
   if {[sb get $name stat] == "n"} {
      sb set $name stat "i"
      cmsn_invite_user $name [lindex [sb get $name last_user] 0]
      cmsn_msgwin_top $name \
         "[trans reconnect [sb get $name last_user]]..."
   } elseif {[sb get $name stat] == "d"} {
      sb set $name stat "rc"
      sb set $name invite [lindex [sb get $name last_user] 0]
      write_ns_sock "XFR" "SB" "cmsn_open_sb $name"
      cmsn_msgwin_top $name "[trans reconnecting]..."
   }
}

proc cmsn_ns_handler {item} {
   global list_cmdhnd password

   set item [encoding convertfrom utf-8 $item]
   set item [string map {\r ""} $item]

   set ret_trid [lindex $item 1]
   set idx [lsearch $list_cmdhnd "$ret_trid *"]
   if {$idx != -1} {		;# Command has a handler associated!
      eval "[lindex [lindex $list_cmdhnd $idx] 1] \"$item\""
      status_log "evaluating handler for $ret_trid\n"
      return 0
   } else {
   switch [lindex $item 0] {
      VER -
      INF -
      USR {
	 return [cmsn_auth $item]
      }
      XFR {
	 if {[lindex $item 2] == "NS"} {
	    set tmp_ns [split [lindex $item 3] ":"]
            sb set ns serv $tmp_ns
            status_log "got a NS transfer!\n"
            status_log "reconnecting to [lindex $tmp_ns 0]\n"
            cmsn_ns_connect
            return 0
	 } else {
            status_log "got an unknown transfer!!\n" red
            return 0
	 }
      }
      RNG {
         return [cmsn_rng $item]
      }
      REA {
         global user_info
         set user_info $item
	 cmsn_draw_online
	 return 0
      }
      ADD -
      LST {
         cmsn_listupdate $item
         return 0
      }
      REM {
         cmsn_listdel $item
         return 0
      }
      MSG {
         cmsn_ns_msg $item
	 return 0
      }
      FLN -
      ILN -
      NLN {
         cmsn_change_state $item
	 return 0
      }
      CHG {
	 global user_stat
	 set user_stat [lindex $item 2]
	 cmsn_draw_online
	 return 0
      }
      GTC -
      BLP -
      SYN {
	 return 0
      }
      911 {
          status_log "User/Password error\n" white
	  set password ""
	  msg_box "[trans baduserpass]"
          return 0;        
      }
      default {
         status_log "RECV: -[join $item]-\n" green
         status_log "Got unknown NS input!! --> [lindex $item 0]\n" red
	 return 0
      }
   }
   }

}

proc cmsn_change_state {recv} {
   global list_fl list_users


   if {[lindex $recv 0] == "FLN"} {
      set user [lindex $recv 1]
      set user_name ""
      set substate "FLN"
   } else {
      if {[lindex $recv 0] == "ILN"} {
         set user [lindex $recv 3]
         set user_name [urldecode [lindex $recv 4]]
         set substate [lindex $recv 2]
      } else {
         set user [lindex $recv 2]
         set user_name [urldecode [lindex $recv 3]]
         set substate [lindex $recv 1]
      }
   }

   set idx [lsearch $list_users "$user *"]
   if {$idx != -1} {
      global list_users list_states

      set user_data [lindex $list_users $idx]
      if {$user_name == ""} {
         set user_name [urldecode [lindex $user_data 1]]
      }

      if {$user_name != [urldecode [lindex $user_data 1]]} {
      	#Nick differs from the one on our list, so change it
	#in the server list too
	write_ns_sock "REM" "FL $user"
	write_ns_sock "ADD" "FL $user [urlencode $user_name]"
      }

      
      if {[lindex $user_data 2] < 7} {		;# User was online before
         set oldusername [string map {\\ \\\\ \[ \\\[ * \\* ? \\?} \
	   [urldecode [lindex $user_data 1]]]

#         status_log "Deleting <$oldusername> from menu\n" white
#         if [catch {.main_menu.msg delete "$oldusername <$user>"} res] {
#	   status_log " ERROR deleting <$oldusername> from message menu\n" white
#	 }
      } elseif {[lindex $recv 0] == "NLN"} {	;# User was offline, now online
            cmsn_notify_add $user_name\n[trans logsin]. "cmsn_chat_user $user"
	    sonido online
      }

      if {$substate != "FLN"} {
#      	 status_log "Inserting <$user_name> in menu\n" white
#         .main_menu.msg insert 0 command -label "$user_name <$user>" \
#            -command "cmsn_chat_user $user"
      }

      set state_no [lsearch $list_states "$substate *"]

      set list_users [lreplace $list_users $idx $idx [list $user $user_name $state_no]]
      set list_users [lsort -decreasing -index 2 [lsort -decreasing -index 1 $list_users]]

      cmsn_draw_online
   } else {
      puts "PANIC!"
   }

}

proc aim_get_str { body str } {
    set pos [string first $str $body]
    if { $pos < 0 } {
      status_log "aim_get_str not found\n"
      return ""
    } else {
	    set inicio [expr { $pos + [string length $str] + 2 } ]
	    set fin [expr { $inicio + [string first "\n" [string range $body $inicio end]] - 1 } ]
	    return [string range $body $inicio $fin]
    }	   

}

proc cmsn_ns_msg {recv} {

   set msg [sb index ns data 1]
   sb ldel ns data 1
   
   
   status_log "[lindex $recv 2] ([lindex $recv 1]) says:\n" green
   status_log "$msg\n" green
   status_log "=========================================\n" green
}

proc list_users_refresh {} {
   global list_fl list_users list_states

   set list_users_new [list]
   set fln [lsearch $list_states "FLN *"]

   foreach user $list_fl {
      set user_login [lindex $user 0]
      set user_name [lindex $user 1]
      set idx [lsearch $list_users "$user_login *"]
      if {$idx != -1} {
         lappend list_users_new [lindex $list_users $idx]
      } else {
         lappend list_users_new [list $user_login $user_name $fln]
      }
   }

   set list_users [lsort -decreasing -index 2 [lsort -decreasing -index 1 $list_users_new]]
   cmsn_draw_online

}

proc lists_compare {} {
   global list_fl list_al list_bl list_rl
   global newc_allow_block newc_add_to_list newc_exit
   set list_albl [lsort [concat $list_al $list_bl]]
   set list_rl [lsort $list_rl]

   foreach x $list_rl {
      if {[lsearch $list_albl "[lindex $x 0] *"] == -1} {
         status_log "$x in your RL list but not in your AL/BL list!\n" white
	 newcontact [lindex $x 0] [lindex $x 1]
         tkwait window .newc 
         if {$newc_exit == "OK"} {
	    if {$newc_allow_block == "allow"} {
	       write_ns_sock "ADD" "AL [lindex $x 0] [urlencode [lindex $x 1]]"
	    } else {
	       write_ns_sock "ADD" "BL [lindex $x 0] [urlencode [lindex $x 1]]"
	    }
	    if {$newc_add_to_list} {
	       write_ns_sock "ADD" "FL [lindex $x 0] [urlencode [lindex $x 1]]"
	    }
	 } else {;# if clicked on OK, by default Accept List	  
	       write_ns_sock "ADD" "AL [lindex $x 0] [urlencode [lindex $x 1]]"
	 }

      } ;# NOT in AL/BL
   }
}

proc cmsn_listupdate {recv} {
   global list_fl list_al list_bl list_rl

   set list_name "list_[string tolower [lindex $recv 2]]"

   if {([lindex $recv 4] <= 1) && ([lindex $recv 0] == "LST")} {
      set $list_name [list]
      status_log "clearing $list_name\n"
   }

   if {[lindex $recv 0] == "ADD"} {		;# FIX: guess I should really
      set recv [linsert $recv 4 "1" "1"]	;# get it out of here!!
   }

   if {[lindex $recv 4] != 0} {
      set contact_info ""
      set user [lindex $recv 6]
      lappend contact_info $user
      lappend contact_info [urldecode [lindex $recv 7]]
      lappend $list_name $contact_info
      status_log "adding to $list_name $contact_info\n"
   }

   if {[lindex $recv 4] == [lindex $recv 5]} {
      lists_compare		;# FIX: hmm, maybe I should not run it always!
      list_users_refresh
   }
}

proc show_list {list_name} {
   upvar #0 $list_name the_list

   status_log "$list_name\n" red
   foreach x $the_list {
      status_log "$x\n"
   }
}

proc cmsn_listdel {recv} {
   write_ns_sock "LST" "[lindex $recv 2]"
}

proc cmsn_auth {{recv ""}} {

   switch [sb get ns stat] {
      c {
         write_ns_sock "VER" "MSNP2"
	 sb set ns stat "v"
	 return 0
      }
      v {
         if {[lindex $recv 0] != "VER"} {
	    status_log "was expecting VER reply but got a [lindex $recv 0]\n" red
	    return 1
	 } elseif {[lsearch -exact $recv "MSNP2"] != -1} {
            write_ns_sock "INF" ""
	    sb set ns stat "i"
	    return 0
	 } else {
	    status_log "could not negotiate protocol!\n" red
	    return 1
	 }
      }
      i {
         if {[lindex $recv 0] != "INF"} {
	    status_log "was expecting INF reply but got a [lindex $recv 0]\n" red
            return 1
         } elseif {[lsearch -exact $recv "MD5"] != -1} {
            global config
            write_ns_sock "USR" "MD5 I $config(login)"
            sb set ns stat "u"
            return 0
         } else {
            status_log "could not negotiate authentication method!\n" red
            return 1
         }
      }
      u {
         if {([lindex $recv 0] != "USR") || \
            ([lindex $recv 2] != "MD5") || \
            ([lindex $recv 3] != "S")} {
            status_log "was expecting USR x MD5 S xxxxx but got something else!\n" red
            return 1
         }
         write_ns_sock "USR" "MD5 S [get_password 'MD5' [lindex $recv 4]]"
         sb set ns stat "us"
         return 0
      }
      us {
         if {[lindex $recv 0] != "USR"} {
            status_log "was expecting USR reply but got a [lindex $recv 0]\n" red
            return 1
         }
         if {[lindex $recv 2] != "OK"} {
            status_log "error authenticating with server!\n" red
            return 1
         }
         global user_info
         set user_info $recv
         sb set ns stat "a"
	 save_config						;# CONFIG
	 write_ns_sock "SYN" "0"
# Me pongo online al comenzar
	 write_ns_sock "CHG" "NLN" ; #Era NLN
   #Log out
   .main_menu.file entryconfigure 2 -state normal
   #My status
   .main_menu.file entryconfigure 3 -state normal
   #Add a contact
   .main_menu.tools entryconfigure 0 -state normal
   #Change nick
   .main_menu.actions entryconfigure 2 -state normal
   .options entryconfigure 0 -state normal

#         .main_menu entryconfigure 0 -state normal
#         .main_menu.msn entryconfigure 1 -state normal
#         .main_menu.msn entryconfigure 2 -state normal
#         .main_menu.msn entryconfigure 4 -state normal
#         .main_menu.msn entryconfigure 5 -state normal
	 return 0
      }
   }

}

proc sb_change { sbn } {
	global trid typing config

	if { $typing != $sbn } {
	
		set typing $sbn	

		after 4000 "set typing \"\""
		
		set sock [sb get $sbn sock]

		set msg "MIME-Version: 1.0\r\nContent-Type: text/x-msmsgscontrol\r\nTypingUser: $config(login)\r\n\r\n\r\n"

		set msg_len [string length $msg]
		incr trid
		puts $sock "MSG $trid U $msg_len"
		puts -nonewline $sock $msg
	}
}

proc sb_enter { sbn name } {
   global trid

   set txt [$name get 0.0 end-1c]
   if {[string length $txt] < 1} { return 0 }

   set sock [sb get $sbn sock]
   if {[string index $txt 0] == "/"} {
#      set cmd [string range $txt 1 [string length $txt]]
#      puts $sock $cmd


   } 
   
   if {[sb length $sbn users]} {
      set txt_send [string map {"\n" "\r\n"} $txt]
      set msg "MIME-Version: 1.0\r\nContent-Type: text/plain\r\n\r\n"
      set msg "$msg$txt_send"
      set msg_len [string length $msg]
      set timestamp [clock format [clock seconds] -format %H:%M]
      incr trid
      puts $sock "MSG $trid U $msg_len"
      puts -nonewline $sock $msg
      cmsn_win_write $sbn "\[$timestamp\] [trans yousay]:\n" gray
      cmsn_win_write $sbn "$txt\n" blue
   } else {
      status_log "$sbn: trying to send, nut no users in this session\n" white
      return 0
   }
   $name delete 0.0 end
   focus ${name}
}

proc ns_enter {} {
   puts -nonewline [sb get ns sock] "[.status.enter get]\r\n"
   status_log "SEND: [.status.enter get]\n" red
   .status.enter delete 0 end
}

proc cmsn_socket {name} {
   global config

   if {$config(proxy) != ""} {
      set proxy_serv [split $config(proxy) ":"]
      set tmp_serv [lindex $proxy_serv 0]
      set tmp_port [lindex $proxy_serv 1]
      set next "cmsn_proxy_connect $name"
      set readable_handler "cmsn_proxy_read $name"
      sb set $name stat "pw"
   } else {
      set tmp_serv [lindex [sb get $name serv] 0]
      set tmp_port [lindex [sb get $name serv] 1]
      set readable_handler [sb get $name readable]
      set next [sb get $name connected]
      sb set $name stat "cw"
   }

     set sock [socket -async $tmp_serv $tmp_port]
      sb set $name sock $sock
     fconfigure $sock -buffering none -translation {binary binary} -blocking 0
     fileevent $sock readable $readable_handler
     fileevent $sock writable $next
}

proc cmsn_proxy_read {name} {
   global proxy_header

   set sock [sb get $name sock]
   if {[eof $sock]} {
      close $sock
      sb set $name stat "d"
      status_log "PROXY: $name CLOSED\n" red
   } else {
      if {[gets $sock tmp_data] != -1} {
	 global proxy_header
	 set tmp_data [string map {\r ""} $tmp_data]
	 lappend proxy_header $tmp_data
	 status_log "PROXY RECV: $tmp_data\n"
	 if {$tmp_data == ""} {
	    set proxy_status [split [lindex $proxy_header 0]]
	    if {[lindex $proxy_status 1] != "200"} {
	       close $sock
	       sb set $name stat "d"
	       status_log "PROXY CLOSED: [lindex $proxy_header 0]\n"
               if {$name == "ns"} cmsn_draw_offline ;# maybe should be passed
	       return 1
	    }
	    status_log "PROXY ESTABLISHED: running [sb get $name connected]\n"
            fileevent [sb get $name sock] readable [sb get $name readable]
            eval [sb get $name connected]
         }
      }
   }
}

proc cmsn_proxy_connect {name} {
   fileevent [sb get $name sock] writable {}
   sb set $name stat "pc"
   set tmp_data "CONNECT [join [sb get $name serv] ":"] HTTP/1.0"
   status_log "PROXY SEND: $tmp_data\n"
   puts -nonewline [sb get $name sock] "$tmp_data\r\n\r\n"
}

proc cmsn_ns_connected {} {
   global config


   fileevent [sb get ns sock] writable {}
   sb set ns stat "c"
   cmsn_auth
   if {$config(adverts)} {
     adv_resume   
   }
}

proc cmsn_sb_connected {name} {
   fileevent [sb get $name sock] writable {}
   sb set $name stat "c"
   write_sb_sock $name [sb get $name auth_cmd] [sb get $name auth_param]
   cmsn_msgwin_top $name "[trans indent]..."
}

proc cmsn_ns_connect {} {
   global config unread list_al list_bl list_fl list_rl password

   if { ($config(login) == "") || ($password == "")} {
     cmsn_draw_login
     return
   }


   set list_al [list]
   set list_bl [list]
   set list_fl [list]
   set list_rl [list]      
   status_log "Clearing lists\n"

   if {[sb get ns stat] != "d"} {
      fileevent [sb get ns sock] readable {}
      close [sb get ns sock]
   }

   #Log in
   .main_menu.file entryconfigure 0 -state disabled
   .main_menu.file entryconfigure 1 -state disabled
   #Proxy Config
   .options entryconfigure 1 -state disabled

#   .main_menu.msn entryconfigure 0 -state disabled
#   .main_menu.msn entryconfigure 7 -state disabled

   wm title . "[trans title] - $config(login)"
   cmsn_draw_signin

   sb set ns data [list]
   sb set ns connected "cmsn_ns_connected"
   sb set ns readable "read_ns_sock"

   set unread 0

   cmsn_socket ns
}

proc get_password {method data} {
   global password

   set pass [::md5::md5 $data$password]
   return $pass

}

proc urldecode {str} {
  global url_unmap url_map
    # estracted from ncgi - solves users from needing to install extra packages!
#    regsub -all {\+} $str { } str
#    regsub -all {[][\\\$]} $str {\\&} str
#    regsub -all {%([0-9a-fA-F][0-9a-fA-F])} $str {[format %c 0x\1]} str

#Nuevo a ver si arregla el $ y los corchetes
    regsub -all {[\$]} $str {$url_map(&)} str
    set str [subst -nocommands -nobackslashes $str]
#    status_log "Original: $str\n" white
    regsub -all {%([0-9a-fA-F][0-9a-fA-F])} $str {$url_unmap([string tolower &])} str
#    status_log "Prueba: $str\n" white
#    status_log "Prueba2: [subst -nocommands -nobackslashes $str]\n" white

    return [subst -nocommands -nobackslashes $str]
}

proc urlencode {str} {
   global url_map

#   regsub -all \[^a-zA-Z0-9\)\\\[\\\\]\\\\\] $str {$url_map(&)} str
   regsub -all {[^a-zA-Z0-9\)\[\]\\]} $str {$url_map(&)} str
   set str [subst -nobackslashes -nocommands $str]

   #Special character with problems
   regsub -all {\\} $str $url_map(\\) str
   regsub -all {\)} $str $url_map() str
   regsub -all {\[} $str $url_map(\[) str
   regsub -all {\]} $str $url_map(\]) str

   return [subst -nobackslashes -nocommands -novariables $str]

}
###############################################################
create_dir $HOME
create_dir $log_dir

sb set ns name ns
sb set ns sock ""
sb set ns data [list]
sb set ns serv [split $config(start_ns_server) ":"]
sb set ns stat "d"

load_config							;# CONFIG
scan_languages
load_lang

cmsn_draw_main
cmsn_draw_notify

degt_protocol_win

after 500 proc_ns
after 750 proc_sb

after 1000 cmsn_update_notify

if {$version != $config(last_client_version)} {
   cmsn_draw_about
}

